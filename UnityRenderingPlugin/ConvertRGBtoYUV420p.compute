// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Convert

// with cs.SetTexture
Texture2D<float4> In;
RWTexture2D<float4> Out;

uint Pitch;
uint Shift;

[numthreads(1,1,1)]
void Convert (uint3 id : SV_DispatchThreadID) 
{
	if (id.x < 4)
	{
		//return;
	}

	const uint xRange = 8;
	const uint yRange = 2;

	uint2 pixelPos;
	pixelPos.x = (id.x * xRange) % Pitch;
	pixelPos.y = Pitch - 2 - ((id.x * xRange) / Pitch) * yRange;

    float4 yuv[xRange][yRange];
	for (int x = 0; x < xRange; x++)
	{
		for (int y = 0; y < yRange; y++)
		{
			uint2 rgbPos;
			rgbPos.x = x + pixelPos.x;
			rgbPos.y = y + pixelPos.y;

			float4 rgb = In[rgbPos];
	
			yuv[x][y].x  =  (0.257f * rgb.z) + (0.504f * rgb.y) + (0.098f * rgb.x) + ( 16.f / 255.f);
			yuv[x][y].y  =  (0.439f * rgb.z) - (0.368f * rgb.y) - (0.071f * rgb.x) + (128.f / 255.f);
			yuv[x][y].z  = -(0.148f * rgb.z) - (0.291f * rgb.y) + (0.439f * rgb.x) + (128.f / 255.f); 
			yuv[x][y].w  = 0.0f;
		}
	}

	/*float4 yuv[xRange][yRange];
	for (int x = 0; x < xRange; x++)
	{
		for (int y = 0; y < yRange; y++)
		{
			for (int i = 0; i < 4; i++)
			{
				yuv[x][y][i] = (pixelPos.y + y) / 255.f;
			}
		}
	}*/

	for (int x = 0; x < 2; x++)
	{
		for (int y = 0; y < 2; y++)
		{
			uint2 yPos;
			yPos.x = (((2 * id.x + x) + (y * (Pitch / 4)) + ((id.x * 8 / Pitch) * Pitch / 4)) % Pitch);
			yPos.y = (4 * id.x) / Pitch;

			float4 yPlane;
			for (int i = 0; i < 4; i++)
			{
				yPlane[i] = yuv[(x*4)+i][1-y].x;
			}

			Out[yPos] = yPlane;  
		}
	}

	uint2 uPos;
	uPos.x = id.x % Pitch;
	uPos.y = id.x / Pitch + Pitch / 4;

	float4 uPlane;
	for (int i = 0; i < 4; i++)
	{
		uPlane[i] = 0.0f;
		for (int x = 0; x < 2; x++)
		{
			for (int y = 0; y < 2; y++)
			{
				uPlane[i] += yuv[i*2+x][y].y / 4.0f;
			}
		}
	}

	Out[uPos] = uPlane;
}