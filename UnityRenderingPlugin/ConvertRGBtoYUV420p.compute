// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel Condense
 
RWStructuredBuffer<int> bufColors;

// with cs.SetTexture
Texture2D<float4> In;
RWTexture2D<float4> Out;

Texture2D<float4> InYUV444;
RWTexture2D<float4> OutYUV444;

RWStructuredBuffer<uint> Out2;
RWStructuredBuffer<uint> CondensedPixels;
uint Pitch;
uint Channel;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
	float4 rgb = In[id.xy];

	float4 yuv;
	yuv.x  =  (0.257f * rgb.z) + (0.504f * rgb.y) + (0.098f * rgb.x) + ( 16.f / 255.f);
	yuv.y  =  (0.439f * rgb.z) - (0.368f * rgb.y) - (0.071f * rgb.x) + (128.f / 255.f);
	yuv.z  = -(0.148f * rgb.z) - (0.291f * rgb.y) + (0.439f * rgb.x) + (128.f / 255.f); 
	yuv.w  = 0.0f;

	OutYUV444[id.xy] = yuv; 
	//Out[id.xy] = yuv; 

	
}

[numthreads(8,8,1)]
void Condense (uint3 id : SV_DispatchThreadID) 
{
	uint2 yuvPos;
	yuvPos.x = (id.x * 4) % Pitch;
	yuvPos.y = (id.x * 4) / Pitch;

	float4 yuv0 = InYUV444[yuvPos];
	float4 yuv1 = InYUV444[uint2(yuvPos.x+1, yuvPos.y)];
	float4 yuv2 = InYUV444[uint2(yuvPos.x+2, yuvPos.y)];
	float4 yuv3 = InYUV444[uint2(yuvPos.x+3, yuvPos.y)];

	if (Channel == 0)
	{
		float4 yP;
		yP.x = yuv0.x;
		yP.y = yuv1.x;
		yP.z = yuv2.x;
		yP.w = yuv3.x;

		uint2 yPPos;
		yPPos.x = (id.x) % Pitch;
		yPPos.y = (id.x) / Pitch;
		Out[yPPos] = yP; 
	}
	else if (Channel == 1)
	{
		float4 uP;
		uP.x = yuv0.y;
		uP.y = yuv1.y;
		uP.z = yuv2.y;
		uP.w = yuv3.y;

		uint2 uPPos;
		uPPos.x = (id.x) % Pitch;
		uPPos.y = (id.x) / Pitch + Pitch / 4;
		//uPPos.x = (id.x) % Pitch;
		//uPPos.y = (id.x) / Pitch;
		Out[uPPos] = uP;
	}
	else if (Channel == 2)
	{
		float4 vP;
		vP.x = yuv0.z;
		vP.y = yuv1.z;
		vP.z = yuv2.z;
		vP.w = yuv3.z; 

		uint2 vPPos;
		vPPos.x = (id.x) % Pitch;
		vPPos.y = (id.x) / Pitch + Pitch / 2;
		Out[vPPos] = vP;
	}
}